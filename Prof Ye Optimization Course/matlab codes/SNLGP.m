		function [X]=SNLGP(PP,m,n,Radius,nf,degree,beta)    %     % PP: sensor point positions    % m: number of anchors, they are PP(:,1:m)    % n: number of total points, they are PP(:,1:n)    % Radius: like a radio range; the distance estimation of two points whose     % distance is less than Radius will be used by the algorithm. Other    % paris wise distances are assummed greater than Radius    % nf: noise factor. The distance estimation between two nearby points    % is computed by true-distance*(1+randn(1)*nf).    % beta: the Lipschitz constant     % X: position estimation for all n-m unknown ints.    %    %    close all;    dd=n-m+2;    A=sparse(dd,1);    %    mtotal=0;    %    % Set up pair-wise distances within R limit between anchors to sensors    %    for i=1:m        flag = 0 ;        for j=m+1:n                        rr= norm(PP(:,i)-PP(:,j))*max(0,(1+randn(1)*nf));                        if rr < Radius && flag < degree               flag =flag+1;               mtotal=mtotal+1;               a=sparse(dd,1);               a(1:2)=PP(:,i);               a(j-m+2)=-1;               A(:,mtotal)=a;               b(mtotal) = rr^2;            end;        end;    end;    %    % Set up pair-wise distances within R limit between sensors to sensors    %    for i=m+1:n        flag = 0 ;        for j=(i+1):n                        rr= norm(PP(:,i)-PP(:,j))*max(0,(1+randn(1)*nf));                        if rr < Radius && flag < degree               flag =flag+1;               mtotal=mtotal+1;               a=sparse(dd,1);               a(i-m+2)=1;               a(j-m+2)=-1;               A(:,mtotal)=a;               b(mtotal) = rr^2;            end;        end;    end;    % Perform the gradient steps    X=zeros(2,dd);    X(:,1:2)=speye(2,2);    for k=1:600;    % Compute the gradient        G=sparse(dd,dd);        for i=1:mtotal,            a=A(:,i);            G=G+(norm(X*a)^2-b(i))*(a*a');        end;        % compute few e-value/vectors        [X,D]=eigs(X'*X-(1/beta)*G);        % select the top 2        X=X(:,1:2)';        %do projection        X=X(:,1:2)\X;    end;    % Plot the position estimations    X=X(:,3:dd);    %X=X(:,1:2)\X(:,3:dd);    figure(1);    hold on ;    plot(PP(1,1:m),PP(2,1:m),'d');        grid on;    	plot(X(1,:),X(2,:),'*r');	plot(PP(1,m+1:n),PP(2,m+1:n),'og');    